<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Red, Green, Rewrite</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Red, Green, Rewrite">
<meta property="og:url" content="http://red-green-rewrite.github.io/index.html">
<meta property="og:site_name" content="Red, Green, Rewrite">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Milosz Krajewski">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Red, Green, Rewrite" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-94127827-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Red, Green, Rewrite</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://red-green-rewrite.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Saving-New-York-with-F-Bloxorz-and-John-McClane" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/10/Saving-New-York-with-F-Bloxorz-and-John-McClane/" class="article-date">
  <time datetime="2018-03-10T20:42:53.000Z" itemprop="datePublished">2018-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/10/Saving-New-York-with-F-Bloxorz-and-John-McClane/">Saving New York with F#, Bloxorz and John McClane</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Quick-links"><a href="#Quick-links" class="headerlink" title="Quick links"></a>Quick links</h2><ul>
<li><a href="/2016/09/14/Maze-generator-with-Fable/">Randomized depth-first search</a></li>
<li><a target="_blank" rel="noopener" href="http://www.bloxorz.org.uk/">Bloxorz</a></li>
<li><a target="_blank" rel="noopener" href="https://bit.ly/2qjPgjZ">Functional Program Design in Scala</a></li>
<li><a target="_blank" rel="noopener" href="https://bit.ly/2JCfYfS">Gist for fable.io/repl</a></li>
<li><a target="_blank" rel="noopener" href="http://fable.io/repl">fable.io/repl</a></li>
<li><a href="/resources/bloxorz/index.html">Online demo</a></li>
<li><a target="_blank" rel="noopener" href="https://bit.ly/2qqCIGW">Gist with bits and bobs</a></li>
</ul>
<h2 id="Rant-just-a-little-one"><a href="#Rant-just-a-little-one" class="headerlink" title="Rant (just a little one)"></a>Rant (just a little one)</h2><p>First book I ever read on computer science was “<em>Algorithms + Data Structures = Programming</em>“ by Niklaus Wirth. For a very long time, my favorite one was “<em>Introduction To Algorithms</em>“ by Thomas Cormen. You can see the pattern, right?</p>
<p>It the era of JSON-over-HTTP neither algorithms nor data structures and considered necessary for programming. Actually, it is considered a success if someone <em>choses</em> the right data structure, not mentioning implementing it or, at least, understanding how it works. It is kind of understandable as it is no longer required to understand B+ Trees to use SQL database.</p>
<p>But it helps. And it is fun.</p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><em>Breadth-First Search</em> is tree traversal algorithm. Because tree is a graph without cycles, by just tracking visited nodes (and preventing cycles) we can use it to build spanning tree of any graph.<br>I touched the topic of spanning trees quite some time ago while writing about <a href="/2016/09/14/Maze-generator-with-Fable/">maze generation</a> (which can be implemented as “random spanning tree”).</p>
<p><em>Breadth-First Search</em> can be expressed with three steps:</p>
<ul>
<li>take first node from the queue, mark it as visited and return it</li>
<li>append all unvisited child nodes to the end of the queue</li>
<li>rinse and repeat</li>
</ul>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bfs idof fanout node =</span><br><span class="line">    <span class="keyword">let</span> queue = Queue([node])</span><br><span class="line">    <span class="keyword">let</span> visited = HashSet()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DSL</span></span><br><span class="line">    <span class="keyword">let</span> enqueue = queue.Enqueue</span><br><span class="line">    <span class="keyword">let</span> dequeue = queue.Dequeue</span><br><span class="line">    <span class="keyword">let</span> empty () = queue.Count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> mark = idof &gt;&gt; visited.Add &gt;&gt; ignore</span><br><span class="line">    <span class="keyword">let</span> test = idof &gt;&gt; visited.Contains &gt;&gt; not</span><br><span class="line"></span><br><span class="line">    <span class="comment">// algorithm</span></span><br><span class="line">    seq &#123;</span><br><span class="line">        <span class="keyword">while</span> not (empty ()) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">let</span> current = dequeue ()</span><br><span class="line">            mark current</span><br><span class="line">            <span class="keyword">yield</span> current</span><br><span class="line">            current |&gt; fanout |&gt; Seq.filter test |&gt; Seq.iter enqueue</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>This is neither the most generic implementation of BFS nor the (functionally) purest. For example, both <code>Queue</code> and <code>HashSet</code> are mutable data structures and it uses <code>while</code> loop instead of recurrence, but in this case it is probably most pragmatic one. There is no problem with imperative code in F# (multi-paradigm, functioanl first) as long as it is properly encapsulated. You can read more about this on <a target="_blank" rel="noopener" href="https://bit.ly/2Ezs7hY">Eirik Tsarpalis’ blog</a>.</p>
<p>You can see I’m a fan of micro DSLs which allow me express “the essence” without any technical noise. It makes implementation a little bit longer sometimes, but in my opinion, much more readable. There are multiple ways to make this implementation slighlty bit shorter (first step would be using <a href="/2016/09/14/Use-apply-and-carry-on/"><code>tap/tee</code></a> function in few places), but they don’t improve readability so I’ll leave it as it is.</p>
<p>Let’s talk about this function then.</p>
<p>The types are properly inferred by F# compiler and there is no need to declare them explicitly but in this case it would be actually beneficial to do it (adding explicit type declaration on public interfaces is generally a good idea):</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bfs (idof: &#x27;node -&gt; &#x27;id) (fanout: &#x27;node -&gt; &#x27;node seq) (node: &#x27;node) = <span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>So:</p>
<ul>
<li><code>idof: &#39;node -&gt; &#39;id</code>: a function which will take the node and generate something which can be considered node’s id; if node is its own id it would be sufficient to use built-in <code>id</code> function (which is <code>fun x -&gt; x</code>); please note, that it is actually <em>ids</em> which are stored in <code>HashSet</code> and used to determine visited nodes;</li>
<li><code>fanout: &#39;node -&gt; &#39;node seq</code> (to be more precise <code>&#39;node -&gt; &#39;nodes when &#39;nodes :&gt; seq&lt;&#39;node&gt;</code>): a function which will take a single node and return all adjacent nodes (in tree they would be just child nodes)</li>
<li><code>node: &#39;node</code>: a starting node</li>
</ul>
<p>Let’s test it with some simple tree defined as <code>Map&lt;int, int list&gt;</code>.</p>
<p>I would use example from wikipedia:</p>
<p><img src="/images/bloxorz/bfs-123.png" alt="BFS"></p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tree =</span><br><span class="line">    [</span><br><span class="line">        <span class="number">1</span>, [<span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]</span><br><span class="line">        <span class="number">2</span>, [<span class="number">5</span>; <span class="number">6</span>]</span><br><span class="line">        <span class="number">5</span>, [<span class="number">9</span>; <span class="number">10</span>]</span><br><span class="line">        <span class="number">4</span>, [<span class="number">7</span>; <span class="number">8</span>]</span><br><span class="line">        <span class="number">7</span>, [<span class="number">11</span>; <span class="number">12</span>]</span><br><span class="line">    ]</span><br><span class="line">    |&gt; Map.ofSeq</span><br></pre></td></tr></table></figure>

<p><code>Map.find</code> (which is <code>int -&gt; int list</code>) matches almost exactly signature required by <code>fanout</code> (<code>&#39;node -&gt; &#39;node seq</code>) but let’s make it a little bit more resilient by using <code>Map.tryFind</code>:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fanout node = tree |&gt; Map.tryFind node |&gt; Option.defaultValue []</span><br></pre></td></tr></table></figure>

<p>It will <em>try to find</em> <code>node</code> in <code>tree</code> and return list of its children. If no children are found it will return empty list (<code>[]</code>).</p>
<p>Now we can call it:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfs id fanout <span class="number">1</span> |&gt; List.ofSeq</span><br></pre></td></tr></table></figure>

<p>and… (drum roll):</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>; <span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>; <span class="number">5</span>; <span class="number">6</span>; <span class="number">7</span>; <span class="number">8</span>; <span class="number">9</span>; <span class="number">10</span>; <span class="number">11</span>; <span class="number">12</span>]</span><br></pre></td></tr></table></figure>

<p>Yay! Exactly as expented. You can add cycles (for example: <code>2, [5, 6, 1]</code>) to test if cycles are properly eliminated.</p>
<p><strong>NOTE</strong>: To run it in <a target="_blank" rel="noopener" href="http://fable.io/repl">fable.io/repl</a> you will need to polyfill <code>Queue</code>, for example:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Queue</span>&lt;<span class="title">&#x27;a</span>&gt;</span>(values: <span class="symbol">&#x27;a</span> seq) =</span><br><span class="line">    <span class="keyword">let</span> values = ResizeArray(values)</span><br><span class="line">    <span class="keyword">member</span> x.Count = values.Count</span><br><span class="line">    <span class="keyword">member</span> x.Enqueue value = values.Add(value)</span><br><span class="line">    <span class="keyword">member</span> x.Dequeue () = <span class="keyword">let</span> result = values.[<span class="number">0</span>] <span class="keyword">in</span> values.RemoveAt(<span class="number">0</span>); result</span><br></pre></td></tr></table></figure>

<h2 id="Scanning-directories-with-BFS"><a href="#Scanning-directories-with-BFS" class="headerlink" title="Scanning directories with BFS"></a>Scanning directories with BFS</h2><p>One of the examples of tree traversal algorithms is listing directories. I never really cared which tree traversal algorithm, DFS or BFS, is used for that. I was actually suprised that Unix <code>find</code> works differently than PowerShell <code>gci</code> (<code>Get-ChildItem</code>). Apparently, <code>find</code> uses DFS while <code>gci</code> uses BFS.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -<span class="built_in">type</span> d | less</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gci</span> <span class="literal">-r</span> <span class="literal">-dir</span> | % &#123; <span class="variable">$_</span>.FullName &#125; | <span class="built_in">oh</span> <span class="literal">-p</span></span><br></pre></td></tr></table></figure>

<p>Let’s assume I want to do something like <code>Get-ChildItem</code> (or like <code>find</code>, but with BFS). How can I implement this using <code>bfs</code> method?</p>
<p>First question is: what is the node? The node in this case is directory. Directory access in .NET can be done with <code>DirectoryInfo</code> class from <code>System.IO</code> namespace. What is <code>fanout</code> function? This function will take take a directory and return list of child directories. Last thing left is <code>idof</code> function returning something which can be used to uniquely identify directory. Let’s say full directory name is good enough in this case (although, something like “inode” or “files system object id” would be much better, as it would resolve potential sym-link cycles).</p>
<p>So, having <code>idof</code>, <code>fanout</code> and <code>node</code> defined as follows:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> System.IO</span><br><span class="line"><span class="keyword">let</span> node = DirectoryInfo(<span class="string">&quot;.&quot;</span>)</span><br><span class="line"><span class="keyword">let</span> idof (node: DirectoryInfo) = node.FullName</span><br><span class="line"><span class="keyword">let</span> fanout (node: DirectoryInfo) = node.EnumerateDirectories(<span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>we can run it with:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bfs idof fanout node |&gt; Seq.toList</span><br></pre></td></tr></table></figure>

<p>…and get list of all child directories.</p>
<p>Let’s refactor this into a function:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scanFolders path = <span class="comment">// string -&gt; string seq</span></span><br><span class="line">    <span class="keyword">let</span> node = DirectoryInfo(path)</span><br><span class="line">    <span class="keyword">let</span> fanout (node: DirectoryInfo) = node.EnumerateDirectories(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> idof (node: DirectoryInfo) = node.FullName</span><br><span class="line">    bfs idof fanout node |&gt; Seq.map idof</span><br></pre></td></tr></table></figure>

<p>which takes <code>path</code> as input and returns sequence of folder names (<code>scanFolders: string -&gt; string seq</code>).<br>We can run it with, for example:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanFolders <span class="string">&quot;.&quot;</span> |&gt; Seq.iter (printfn <span class="string">&quot;%s&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>Please note, that this time we really needed to use <code>idof</code> as <code>DirectoryInfo</code> is an object without structural equality so <code>DirectoryInfo(&quot;.&quot;) != DirectoryInfo(&quot;.&quot;)</code>. To compare them we needed something else, something comparable and <code>DirectoryInfo.FullName</code> look like a good-enough choice.</p>
<p>It would be actually safer to use slightly modified version of <code>fanout</code> to suppress exceptions in directories which we have no access to:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fanout (node: DirectoryInfo) =</span><br><span class="line">    <span class="keyword">try</span> node.EnumerateDirectories(<span class="string">&quot;*&quot;</span>) <span class="keyword">with</span> | _ -&gt; Seq.empty</span><br></pre></td></tr></table></figure>

<h2 id="Tracing-the-path"><a href="#Tracing-the-path" class="headerlink" title="Tracing the path"></a>Tracing the path</h2><p>Sometimes, apart from getting there (visiting nodes) it is important to know “how we got there” (keeping a history of decisions). We do not want to rewrite <code>bfs</code>, we would like to reuse it. Let’s call this new method <code>trace</code>. So far, <code>bfs</code> is taking <code>node</code> (<code>&#39;node</code>) and <code>fanout</code> function (<code>fanout: &#39;node -&gt; &#39;node seq</code>) and returns a sequence of nodes (<code>&#39;node seq</code>).</p>
<p>This paragraph, describing transformation from <code>bfs</code> into <code>trace</code> is probably the most convoluted one in this post. I tried to rewrite it many times but I couldn’t make it simpler (my fault). It is very important though, so please read multiple times until you think you understand what happens here.</p>
<p>We want <code>trace</code> to return not only a sequence of nodes (<code>&#39;node seq</code>) as <code>bfs</code> does but also a history of actions which led to this node: <code>(&#39;node * &#39;action list) seq</code>. Look again, instead of sequence of <code>&#39;node</code> we want a sequence of <code>&#39;node * &#39;action list</code>. We don’t know nor care what <code>&#39;action</code> is. We want it to be provided from <code>fanout</code>. The new <code>fanout</code> will not only return a sequence of child nodes (<code>&#39;node -&gt; &#39;node seq</code>) but also an <code>action</code> which caused this transition. New <code>fanout</code> will be <code>&#39;node -&gt; (&#39;node * &#39;action) seq</code> - taking node and returning sequence of child nodes and actions leading to them. We will reuse <code>bfs</code> by providing little adapter functions for <code>idof</code>, <code>fanout</code> and <code>node</code>.</p>
<p>Both <em>new</em> <code>node</code> and <em>new</em> <code>idof</code> are relatively simple. New starting node is a node with empty action history while <em>new</em> <code>idof</code> will just ignore action history (as how we got to given node does not affect node’s identity):</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node&#x27; = (node, [])</span><br><span class="line"><span class="keyword">let</span> idof&#x27; (node, actions) = idof node</span><br></pre></td></tr></table></figure>

<p>Adapter for <code>fanout</code> is a little bit more complicated. The node passed to <code>bfs</code> is no longer just node, but also contains action history (<code>&#39;node * &#39;action list</code>) so <code>fanout</code> expected by <code>bfs</code> should be <code>&#39;node * &#39;action list -&gt; (&#39;node * &#39;action list) seq</code>, but it isn’t. Our new <code>fanout</code> (for <code>trace</code>) is (as mentioned before) <code>&#39;node -&gt; (&#39;node * &#39;action) seq</code>. So, we will need another adapter:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fanout&#x27; (node, actions) = node |&gt; fanout |&gt; Seq.map (<span class="keyword">fun</span> (n, a) -&gt; (n, a :: actions))</span><br></pre></td></tr></table></figure>

<p>Now, types match again: <code>fanout</code> is <code>&#39;node -&gt; (&#39;node * &#39;action) seq</code> while <code>fanout&#39;</code> is <code>&#39;node * &#39;action list -&gt; (&#39;node * &#39;action list) seq</code>.</p>
<p>Let me try to explain one more time: <code>fanout&#39;</code> will take a pair of <code>node</code> and <code>actions</code> (leading to this node), it will use <code>fanout</code> with <code>node</code> (action history is irrelevant at this point) returning sequence of <em>nodes and actions</em> (<code>n, a</code>) and create new states with those new nodes and new action prepended to history (<code>fun (n, a) -&gt; (n, a :: actions)</code>).</p>
<p>So, whole <code>trace</code> function is:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trace idof fanout node =</span><br><span class="line">    <span class="keyword">let</span> node&#x27; = (node, [])</span><br><span class="line">    <span class="keyword">let</span> idof&#x27; (node, _) = idof node</span><br><span class="line">    <span class="keyword">let</span> fanout&#x27; (node, actions) = node |&gt; fanout |&gt; Seq.map (<span class="keyword">fun</span> (n, a) -&gt; (n, a :: actions))</span><br><span class="line">    bfs idof&#x27; fanout&#x27; node&#x27;</span><br></pre></td></tr></table></figure>

<p>Please note that new actions are prepended to action list (<code>a :: actions</code>) so actions will be returned in reversed order. It is not a problem, it is just worth remembering.</p>
<p>Let’s run it using the <code>tree</code> we used before.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tree =</span><br><span class="line">    [</span><br><span class="line">        <span class="number">1</span>, [<span class="number">2</span>; <span class="number">3</span>; <span class="number">4</span>]</span><br><span class="line">        <span class="number">2</span>, [<span class="number">5</span>; <span class="number">6</span>]</span><br><span class="line">        <span class="number">5</span>, [<span class="number">9</span>; <span class="number">10</span>]</span><br><span class="line">        <span class="number">4</span>, [<span class="number">7</span>; <span class="number">8</span>]</span><br><span class="line">        <span class="number">7</span>, [<span class="number">11</span>; <span class="number">12</span>]</span><br><span class="line">    ]</span><br><span class="line">    |&gt; Map.ofSeq</span><br></pre></td></tr></table></figure>

<p>The only question is what we want the <code>action</code> to be in this case? There is no <em>left</em> or <em>right</em>, as the only decision is <em>down</em>. Let’s use source node as action, so the <em>history of actions</em> will be actually <em>history of nodes</em>.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fanout node =</span><br><span class="line">    <span class="keyword">let</span> children = tree |&gt; Map.tryFind node |&gt; Option.defaultValue []</span><br><span class="line">    children |&gt; Seq.map (<span class="keyword">fun</span> n -&gt; (n, node))</span><br></pre></td></tr></table></figure>

<p>We can run it now:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace id fanout <span class="number">1</span> |&gt; List.ofSeq</span><br></pre></td></tr></table></figure>

<p>and get the all the nodes with traversal history:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    (<span class="number">1</span>, []); (<span class="number">2</span>, [<span class="number">1</span>]); (<span class="number">3</span>, [<span class="number">1</span>]); (<span class="number">4</span>, [<span class="number">1</span>]); (<span class="number">5</span>, [<span class="number">2</span>; <span class="number">1</span>]); (<span class="number">6</span>, [<span class="number">2</span>; <span class="number">1</span>]);</span><br><span class="line">    (<span class="number">7</span>, [<span class="number">4</span>; <span class="number">1</span>]); (<span class="number">8</span>, [<span class="number">4</span>; <span class="number">1</span>]); (<span class="number">9</span>, [<span class="number">5</span>; <span class="number">2</span>; <span class="number">1</span>]); (<span class="number">10</span>, [<span class="number">5</span>; <span class="number">2</span>; <span class="number">1</span>]); (<span class="number">11</span>, [<span class="number">7</span>; <span class="number">4</span>; <span class="number">1</span>]);</span><br><span class="line">    (<span class="number">12</span>, [<span class="number">7</span>; <span class="number">4</span>; <span class="number">1</span>])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>We can of course process it further, prepending final node to history and then reversing order:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace id fanout <span class="number">1</span> |&gt; Seq.map (List.Cons &gt;&gt; List.rev) |&gt; List.ofSeq</span><br></pre></td></tr></table></figure>

<p>to transform it to paths:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [<span class="number">1</span>]; [<span class="number">1</span>; <span class="number">2</span>]; [<span class="number">1</span>; <span class="number">3</span>]; [<span class="number">1</span>; <span class="number">4</span>]; [<span class="number">1</span>; <span class="number">2</span>; <span class="number">5</span>]; [<span class="number">1</span>; <span class="number">2</span>; <span class="number">6</span>]; [<span class="number">1</span>; <span class="number">4</span>; <span class="number">7</span>]; [<span class="number">1</span>; <span class="number">4</span>; <span class="number">8</span>];</span><br><span class="line">    [<span class="number">1</span>; <span class="number">2</span>; <span class="number">5</span>; <span class="number">9</span>]; [<span class="number">1</span>; <span class="number">2</span>; <span class="number">5</span>; <span class="number">10</span>]; [<span class="number">1</span>; <span class="number">4</span>; <span class="number">7</span>; <span class="number">11</span>]; [<span class="number">1</span>; <span class="number">4</span>; <span class="number">7</span>; <span class="number">12</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>This is still not finished thought: <code>trace</code> calls <code>bfs</code> while actually it does not care if underlying algorithm is BFS. It would work absolutely perfectly with any other algorithm (DFS, for example). Let’s extract it then:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trace traverse idof fanout node =</span><br><span class="line">    <span class="keyword">let</span> node&#x27; = (node, [])</span><br><span class="line">    <span class="keyword">let</span> idof&#x27; (node, _) = idof node</span><br><span class="line">    <span class="keyword">let</span> fanout&#x27; (node, actions) = node |&gt; fanout |&gt; Seq.map (<span class="keyword">fun</span> (n, a) -&gt; (n, a :: actions))</span><br><span class="line">    traverse idof&#x27; fanout&#x27; node&#x27;</span><br></pre></td></tr></table></figure>

<p>As you can see, <code>trace</code> does not call <code>bfs</code> directly anymore, it expects function of matching signature to be passed to it. <code>bfs</code> is a perfect candidate, and works perfectly:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace bfs id fanout <span class="number">1</span> |&gt; List.ofSeq</span><br></pre></td></tr></table></figure>

<p>But now, we could use it with (hypothetical) <code>dfs</code> by just changing it to:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace dfs id fanout <span class="number">1</span> |&gt; List.ofSeq <span class="comment">// <span class="doctag">NOTE:</span> you would have to implement dfs yourself</span></span><br></pre></td></tr></table></figure>

<p>Please note, that with one trivial adapter function (<code>idof&#39;</code>), one relatively simple adapter function (<code>fanout&#39;</code>) and injectable traversal algorithm (<code>bfs</code>, <code>dfs</code> or… whatever matches the signature) we have completely new functionality (tracing). Composite Reuse Principle, Single Responsibility Principle, Open/Closed Principle, Interface Segregation Principle and Dependency Inversion Principle. All of those in 5 lines of code.</p>
<h2 id="Bloxorz"><a href="#Bloxorz" class="headerlink" title="Bloxorz"></a>Bloxorz</h2><p>The idea of doing Bloxorz solver comes from <a target="_blank" rel="noopener" href="https://bit.ly/2qjPgjZ">Functional Program Design in Scala</a> course. It is a second week assignment. In does not explicitly mentions BFS as it tries to teach lazy evaluations rather than graph algorithms, but I find a great example how to use BFS.</p>
<p>Unfortunately, it is quite hard to explain how it works, so you will need to play Bloxorz yourself on, for example: <a target="_blank" rel="noopener" href="http://www.bloxorz.org.uk/">http://www.bloxorz.org.uk/</a> (you will also need to enable Flash). If it doesn’t work just google “bloxorz” and you may find multiple sites allowing you to play. If it is year 2050, Flash no longer works, and nobody ported Bloxorz to ES2050, but YouTube still works you can check what it was about here:</p>
<div style="text-align: center">
<iframe width="560" height="315" src="https://www.youtube.com/embed/s9e7G6nOzVo" frameborder="0" allowfullscreen></iframe>
</div>

<p>If you have a feel how Bloxorz work we can start. We will address only the simplest scenarios: no <em>weak squares</em>, no <em>block splitting</em> and no <em>dynamic environment</em>. While <em>weak squares</em> could be actually quite easy to implement, <em>block splitting</em> and <em>dynamic environment</em> would bring a lot of complexity to solution.</p>
<p>As I already hinted we will use BFS to solve Bloxorz puzzles. Knowning that we need to establish what <code>node</code> will be, what <code>idof</code> should return and how <code>fanout</code> should work.</p>
<p>The node is the state/position of the block. The child/adjacent nodes are the valid nodes which can be reached by moving block in any direction. Valid node is the node where both parts of the block are on valid squares. The solution is the path (history of actions) leading to target block position while target block position is block “standing” on top of the goal. Yeah, that’s why you need to play Bloxorz for a while to get a feeling what all those things mean.</p>
<p>Let’s start with a little bit of <em>domain</em>:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Position</span> </span>= int * int</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Bloxor</span> </span>= Position * Position</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Move</span> </span>= | North | East | South | West</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">World</span> </span>= &#123; A: Position; B: Position; IsValid: Position -&gt; bool &#125;</span><br></pre></td></tr></table></figure>

<p>For functional purists: I have to admit that this <em>domain model</em> violates <a target="_blank" rel="noopener" href="https://bit.ly/2GOXmHM">make illegal state unrepresentable</a> principle. For example, we can define split <code>Bloxor</code> while we said we are not handling them. We can also construct a <code>World</code> when one or both (starting and target) positions are illegal. Although, I decided that domain design for Bloxor problem is not really a main topic here.</p>
<p>So, we have <code>Position</code> which represents X and Y coordinates in Bloxor space. We have <code>Bloxor</code> which is a pair of positions (as it consists of two pieces). We have <code>World</code> which has starting position (<code>A</code>), target position (<code>B</code>) and a function answering the question: is given position legal (takes <code>Position</code> and returns <code>true</code> or <code>false</code>).</p>
<p>Let’s define infinite <code>World</code> first:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> infiniteWorld a b = &#123; A = a; B = b; IsValid = <span class="keyword">fun</span> _ -&gt; <span class="keyword">true</span> &#125;</span><br></pre></td></tr></table></figure>

<p>Please note that <code>IsValid</code> always returns <code>true</code>, which means any position is legal, we can roll our bloxor wherever we want. We will implement more complex worlds later but this one will allow us to have something to test our algorithm with.</p>
<p>Let’s define some functions around bloxor behaviour and state. First, <code>makeBloxor</code> will allow us to create a standing bloxor at given position. This is a lot of text to create tuple of points <code>(p, p)</code> but let’s make it official:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> makeBloxor (position: Position): Bloxor = (position, position)</span><br></pre></td></tr></table></figure>

<p>The other helper function would help us determine what is current bloxor orientation:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (|IsStanding|IsHorizontal|IsVertical|) (bloxor: Bloxor) =</span><br><span class="line">    <span class="keyword">let</span> ((ax, ay), (bx, by)) = bloxor</span><br><span class="line">    <span class="keyword">match</span> bx - ax, by - ay <span class="keyword">with</span></span><br><span class="line">    | <span class="number">0</span>, <span class="number">0</span> -&gt; IsStanding</span><br><span class="line">    | <span class="number">1</span>, <span class="number">0</span> -&gt; IsHorizontal</span><br><span class="line">    | <span class="number">0</span>, <span class="number">1</span> -&gt; IsVertical</span><br><span class="line">    | _ -&gt; failwithf <span class="string">&quot;Invalid bloxor (%d,%d) (%d,%d)&quot;</span> ax ay bx by</span><br></pre></td></tr></table></figure>

<p>I assume you are familiar with <em>active patterns</em>, but even if you are not, please imagine three methods (<code>IsStanding</code>, <code>IsHorizontal</code> and <code>IsVertical</code>) so similar that thay share single body… Well, it does not make it any clearer. I guess “Multi-Case Active Patterns” section on <a target="_blank" rel="noopener" href="https://bit.ly/2JwAD53">Chris Smith’s blog</a> explains it better.</p>
<p>This <em>active patterns</em> deconstructs bloxor and recognizes its orientation: standing, horizontal or vertical. It may also throw an exception when bloxor is invalid (including <em>split</em> or just <em>inverted</em>). It requires some discipline how bloxor is constructed but as I said before, <a target="_blank" rel="noopener" href="https://bit.ly/2GOXmHM">MISU</a> principle is not a main concern here.</p>
<p>Next step is to define how bloxor moves. This is really messy function (all those <code>shiftY -2 -1</code> and <code>shiftX -1 -1</code>) but describes all possible moves (<code>North</code>, <code>South</code>, <code>East</code>, <code>West</code>) from all posible startings orientations (<code>IsStanding</code>, <code>IsHorizontal</code>, <code>IsVertical</code>). It decides how bloxor coordinates should be adjusted (<code>let move = match bloxor, direction with ...</code>) and returns new bloxor position (<code>move bloxor</code>).</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> moveBloxor (bloxor: Bloxor) (direction: Move): Bloxor =</span><br><span class="line">    <span class="keyword">let</span> shiftX x1 x2 ((ax, ay), (bx, by)) = (ax + x1, ay), (bx + x2, by)</span><br><span class="line">    <span class="keyword">let</span> shiftY y1 y2 ((ax, ay), (bx, by)) = (ax, ay + y1), (bx, by + y2)</span><br><span class="line">    <span class="keyword">let</span> move =</span><br><span class="line">        <span class="keyword">match</span> bloxor, direction <span class="keyword">with</span></span><br><span class="line">        | IsStanding, North -&gt; shiftY <span class="number">-2</span> <span class="number">-1</span></span><br><span class="line">        | IsStanding, East -&gt; shiftX <span class="number">1</span> <span class="number">2</span></span><br><span class="line">        | IsStanding, South -&gt; shiftY <span class="number">1</span> <span class="number">2</span></span><br><span class="line">        | IsStanding, West -&gt; shiftX <span class="number">-2</span> <span class="number">-1</span></span><br><span class="line">        | IsHorizontal, North -&gt; shiftY <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line">        | IsHorizontal, East -&gt; shiftX <span class="number">2</span> <span class="number">1</span></span><br><span class="line">        | IsHorizontal, South -&gt; shiftY <span class="number">1</span> <span class="number">1</span></span><br><span class="line">        | IsHorizontal, West -&gt; shiftX <span class="number">-1</span> <span class="number">-2</span></span><br><span class="line">        | IsVertical, North -&gt; shiftY <span class="number">-1</span> <span class="number">-2</span></span><br><span class="line">        | IsVertical, East -&gt; shiftX <span class="number">1</span> <span class="number">1</span></span><br><span class="line">        | IsVertical, South -&gt; shiftY <span class="number">2</span> <span class="number">1</span></span><br><span class="line">        | IsVertical, West -&gt; shiftX <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line">    move bloxor</span><br></pre></td></tr></table></figure>

<p>The rules were slowly reconstructed from this picture:</p>
<p><img src="/images/bloxorz/bloxor-move.png" alt="Bloxor moves"></p>
<p>We are ready to write solver function. The <code>solveWorld</code> function will take <code>World</code> (as <code>World</code> is the problem to solve) and return <code>Move list option</code>. We could alias <code>Move list</code> as <code>Path</code> and then returned type would be <code>Path option</code>. It returns <code>option</code> as it possible that solution cannot be found.</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> solveWorld (world: World): Move list option = <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>Let’s go slowly through DSL for this function:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> solveWorld (world: World): Move list option =</span><br><span class="line">    <span class="comment">// DSL</span></span><br><span class="line">    <span class="keyword">let</span> isValid (a, b) = world.IsValid a &amp;&amp; world.IsValid b</span><br><span class="line">    <span class="keyword">let</span> isFinal (a, b) = a = world.B &amp;&amp; b = world.B</span><br><span class="line">    <span class="keyword">let</span> validMoves bloxor =</span><br><span class="line">        [North; South; East; West]</span><br><span class="line">        |&gt; Seq.map (<span class="keyword">fun</span> direction -&gt; (moveBloxor bloxor direction, direction))</span><br><span class="line">        |&gt; Seq.filter (<span class="keyword">fun</span> (bloxor, _) -&gt; isValid bloxor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...more to come...</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>isValid</code>: bloxor position (deconstructed into <code>a</code> and <code>b</code>) is valid when both pieces are valid;</li>
<li><code>isFinal</code>: bloxor position (deconstructed into <code>a</code> and <code>b</code>) is final when both pieces are in final position (meaning: we found the solution);</li>
<li><code>validMoves</code>: try to move bloxor in all directions (<code>[North; South; East; West] |&gt; Seq.map moveBloxor</code>) creating pairs of new bloxor positions and move directions (note: <code>node</code> and <code>action</code>) but filter out all invalid moves (<code>Seq.filter isValid</code>);</li>
</ul>
<p>We are ready now solve bloxorz! The whole function is:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> solveWorld (world: World): Move list option =</span><br><span class="line">    <span class="comment">// DSL</span></span><br><span class="line">    <span class="keyword">let</span> isValid (a, b) = world.IsValid a &amp;&amp; world.IsValid b</span><br><span class="line">    <span class="keyword">let</span> isFinal (a, b) = a = world.B &amp;&amp; b = world.B</span><br><span class="line">    <span class="keyword">let</span> validMoves bloxor =</span><br><span class="line">        [North; South; East; West]</span><br><span class="line">        |&gt; Seq.map (<span class="keyword">fun</span> direction -&gt; (moveBloxor bloxor direction, direction))</span><br><span class="line">        |&gt; Seq.filter (<span class="keyword">fun</span> (bloxor, _) -&gt; isValid bloxor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get ready...</span></span><br><span class="line">    <span class="keyword">let</span> node = makeBloxor world.A</span><br><span class="line">    <span class="keyword">let</span> idof ((ax, ay), (bx, by)) = sprintf <span class="string">&quot;%d.%d.%d.%d&quot;</span> ax ay bx by</span><br><span class="line">    <span class="keyword">let</span> fanout = validMoves</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...action!</span></span><br><span class="line">    trace bfs idof fanout node</span><br><span class="line">    |&gt; Seq.tryFind (<span class="keyword">fun</span> (bloxor, _) -&gt; isFinal bloxor)</span><br><span class="line">    |&gt; Option.map (<span class="keyword">fun</span> (_, actions) -&gt; List.rev actions)</span><br></pre></td></tr></table></figure>

<p>Where:</p>
<ul>
<li><code>node</code>: bloxor initial position at <code>world.A</code>;</li>
<li><code>idof</code>: bloxor position unique identifier - it is just a string with coordinates of both pieces; because of <em>structural equality</em> in F# this is not really needed (built in <code>id</code> would be sufficient) but it wouldn’t work in <a target="_blank" rel="noopener" href="http://fable.io/">Fable</a> (<code>HashSet</code> is not fully compatible);</li>
<li><code>fanout</code>: it is actually <code>validMoves</code> - for every bloxor position returns a sequence of new valid bloxor positions with appropriate moves (<code>Bloxor -&gt; (Bloxor * Move) seq</code>) which is exactly when we wanted for <code>trace</code> (<code>&#39;node -&gt; (&#39;node * &#39;action) seq</code>).</li>
</ul>
<p>So, the last expression is actually running it (<code>trace bfs idof fanout node</code>) which returns a sequence of all paths, and finding first one (shortest!) leading to solutions (<code>Seq.tryFind/isFinal</code>) and taking only the history part (<code>fun (_, actions) -&gt; actions</code>) and reverses it (<code>List.rev</code>). If you’re fan of point-free style, this can be also expressed as:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trace bfs idof fanout node |&gt; Seq.tryFind (fst &gt;&gt; isFinal) |&gt; Option.map (snd &gt;&gt; List.rev)</span><br></pre></td></tr></table></figure>

<p>Let’s try it first with inifinite world:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infiniteWorld (<span class="number">0</span>, <span class="number">0</span>) (<span class="number">1</span>, <span class="number">0</span>) |&gt; solveWorld</span><br></pre></td></tr></table></figure>

<p>produces:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some [North; East; South]</span><br></pre></td></tr></table></figure>

<p>which is the correct answer: solution was found (<code>Some</code>) and the path was <code>North</code>, <code>East</code>, <code>South</code>.</p>
<p>Let’s try a longer path, for example from <code>(0, 0)</code> to <code>(9, 9)</code>. We expect it be 6 times <code>South</code> then 6 times <code>East</code> (or the other way around: 6 times <code>East</code> then 6 times <code>South</code>).</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">infiniteWorld (<span class="number">0</span>, <span class="number">0</span>) (<span class="number">9</span>, <span class="number">9</span>) |&gt; solveWorld</span><br></pre></td></tr></table></figure>

<p>returns:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some [South; South; South; South; South; South; East; East; East; East; East; East]</span><br></pre></td></tr></table></figure>

<p>which confirms our expectations.</p>
<p>As a last step, we can add ability to define more complex worlds. Let’s assume we would like to define world using ASCII, for example:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> world = [</span><br><span class="line">    <span class="string">&quot;      xxxxxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxx  xxx  xx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxxxxxxx  xxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;xAxx       xxBx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxx       xxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;            xxx&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>would represent:</p>
<p><img src="/images/bloxorz/world-2.png" alt="world2"></p>
<p>Note, <em>space</em> represents empty sqaure while <code>A</code> and <code>B</code> are initial position and target position respectively.</p>
<p>We need to create a map of characters (<code>Map&lt;int * int, char&gt;</code>) first:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map =</span><br><span class="line">    world</span><br><span class="line">    |&gt; Seq.mapi (<span class="keyword">fun</span> y l -&gt; l |&gt; Seq.mapi (<span class="keyword">fun</span> x c -&gt; (x, y), c))</span><br><span class="line">    |&gt; Seq.collect id</span><br><span class="line">    |&gt; Map.ofSeq</span><br></pre></td></tr></table></figure>

<p>This does not look too attractive as, in general, nested loops with indexes are not the prettiest constuct in functional languges. The general idea here is to iterate over lines (<code>world |&gt; Seq.mapi</code>) then over characters in line (<code>l |&gt; Seq.mapi</code>), flatten nested list (<code>Seq.collect</code>) and create a map <code>(x, y) -&gt; c</code> (<code>Map.ofSeq</code>).</p>
<p>Having such a map we can determine initial and target positions:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = map |&gt; Map.findKey (<span class="keyword">fun</span> k c -&gt; c = <span class="symbol">&#x27;A</span>&#x27;)</span><br><span class="line"><span class="keyword">let</span> b = map |&gt; Map.findKey (<span class="keyword">fun</span> k c -&gt; c = <span class="symbol">&#x27;B</span>&#x27;)</span><br></pre></td></tr></table></figure>

<p>and define a function which will test if given position is valid:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> valid k = map |&gt; Map.tryFind k |&gt; Option.filter (<span class="keyword">fun</span> c -&gt; c &lt;&gt; &#x27; &#x27;) |&gt; Option.isSome</span><br></pre></td></tr></table></figure>

<p>Having these three bits of information we can construct a <code>World</code> record:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; A = a; B = b; IsValid = valid &#125;</span><br></pre></td></tr></table></figure>

<p>Let’s put all those things together:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parseWorld lines =</span><br><span class="line">    <span class="keyword">let</span> map =</span><br><span class="line">        lines</span><br><span class="line">        |&gt; Seq.mapi (<span class="keyword">fun</span> y l -&gt; l |&gt; Seq.mapi (<span class="keyword">fun</span> x c -&gt; (x, y), c))</span><br><span class="line">        |&gt; Seq.collect id</span><br><span class="line">        |&gt; Map.ofSeq</span><br><span class="line">    <span class="keyword">let</span> a = map |&gt; Map.findKey (<span class="keyword">fun</span> _ c -&gt; c = <span class="symbol">&#x27;A</span>&#x27;)</span><br><span class="line">    <span class="keyword">let</span> b = map |&gt; Map.findKey (<span class="keyword">fun</span> _ c -&gt; c = <span class="symbol">&#x27;B</span>&#x27;)</span><br><span class="line">    <span class="keyword">let</span> valid k = map |&gt; Map.tryFind k |&gt; Option.filter (<span class="keyword">fun</span> c -&gt; c &lt;&gt; &#x27; &#x27;) |&gt; Option.isSome</span><br><span class="line">    &#123; A = a; B = b; IsValid = valid &#125;</span><br></pre></td></tr></table></figure>

<p>For OO fans I would like to emphasize, that you can think about <code>infiniteWorld</code> and <code>parseWorld</code> as two constructors of two different objects implementing the same interface (<code>World</code>).</p>
<p>So, let’s try this example:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> world = [</span><br><span class="line">    <span class="string">&quot;      xxxxxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxx  xxx  xx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxxxxxxx  xxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;xAxx       xxBx&quot;</span></span><br><span class="line">    <span class="string">&quot;xxxx       xxxx&quot;</span></span><br><span class="line">    <span class="string">&quot;            xxx&quot;</span></span><br><span class="line">]</span><br><span class="line">world |&gt; parseWorld |&gt; solveWorld</span><br></pre></td></tr></table></figure>

<p>It returns:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Some [</span><br><span class="line">    North; West; South; East; North; East; East; East; East; North; North;</span><br><span class="line">    East; East; East; South; South; South; East; North</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>I can bet that’s exactly what we need (you can go to <a target="_blank" rel="noopener" href="http://www.bloxorz.org.uk/">http://www.bloxorz.org.uk/</a> and use <code>918660</code> as stage code).</p>
<p>I wrote simple Fable app which shows results as animation:</p>
<ul>
<li>check it <a href="/resources/bloxorz/index.html">here</a></li>
<li>or go to <a target="_blank" rel="noopener" href="https://gist.github.com/MiloszKrajewski/0b9095449474993c8ee4daa9234ff203">gist</a> and paste it into <a target="_blank" rel="noopener" href="http://fable.io/repl">fable.io/repl</a> (you will be able to play with sources a little bit)</li>
</ul>
<h2 id="…but-where-FFS-is-John-McClane"><a href="#…but-where-FFS-is-John-McClane" class="headerlink" title="…but where FFS is John McClane?"></a>…but where FFS is John McClane?</h2><p>…you might ask. Good question. You need to watch this first (ok, YouTube keeps removing this clip, so if it is gone, try <a target="_blank" rel="noopener" href="https://www.youtube.com/results?search_query=die+hard+jug+riddle">this link</a>):</p>
<div style="text-align: center">
<iframe 
    width="560" height="315" frameborder="0" allowfullscreen
    src="https://www.youtube.com/embed/2vdF6NASMiE"></iframe>
</div>

<p>We have solution space (two containers), we have allowed moves (fill, empty, transfer) and a goal (one container contains exactly 4 gallons). Well, this problem is identical to Bloxorz, isn’t it?</p>
<p>Let’s start with domain:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Jug</span> </span>= | A | B</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Action</span> </span>=</span><br><span class="line">    | Empty <span class="keyword">of</span> Jug</span><br><span class="line">    | Fill <span class="keyword">of</span> Jug</span><br><span class="line">    | Transfer <span class="keyword">of</span> Jug * Jug</span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">State</span> </span>=</span><br><span class="line">    &#123; A: int; B: int; MaxA: int; MaxB: int &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Jug</code>: we have two jugs: <code>A</code> and <code>B</code>;</li>
<li><code>Action</code>: possible actions are <em>emptying</em> a jug (<code>Empty</code>), <em>filling</em> a jug (<code>Fill</code>), or transferring water from one jug to another (<code>Transfer</code>);</li>
<li><code>State</code>: state of the system with current and maximum levels;</li>
</ul>
<p>Let me try to draw it:</p>
<p><img src="/images/bloxorz/diehard.png" alt="What John McClane can do?"></p>
<p>We can add some methods to <code>State</code> to make working with this record a little bit easier:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">State</span> </span>=</span><br><span class="line">    &#123; A: int; B: int; MaxA: int; MaxB: int &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">member</span> Create (a, b) = &#123; A = <span class="number">0</span>; B = <span class="number">0</span>; MaxA = a; MaxB = b &#125;</span><br><span class="line">    <span class="keyword">member</span> x.Get j = <span class="keyword">match</span> j <span class="keyword">with</span> | A -&gt; x.A | B -&gt; x.B</span><br><span class="line">    <span class="keyword">member</span> x.Max j = <span class="keyword">match</span> j <span class="keyword">with</span> | A -&gt; x.MaxA | B -&gt; x.MaxB</span><br><span class="line">    <span class="keyword">member</span> <span class="keyword">private</span> x.Set (j, v) = <span class="keyword">match</span> j <span class="keyword">with</span> | A -&gt; &#123; x <span class="keyword">with</span> A = v &#125; | B -&gt; &#123; x <span class="keyword">with</span> B = v &#125;</span><br><span class="line">    <span class="keyword">member</span> <span class="keyword">private</span> x.Add (j, v) = x.Set(j, x.Get j + v)</span><br><span class="line">    <span class="keyword">member</span> x.Empty j = x.Set(j, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">member</span> x.Fill j = x.Set(j, x.Max j)</span><br><span class="line">    <span class="keyword">member</span> x.Transfer j k =</span><br><span class="line">        <span class="keyword">let</span> amount = min (x.Get j) (x.Max k - x.Get k)</span><br><span class="line">        x.Add(j, -amount).Add(k, amount)</span><br></pre></td></tr></table></figure>

<p>Where:</p>
<ul>
<li><code>Get</code>: gets jug level;</li>
<li><code>Max</code>: gets jug capacity;</li>
<li><code>Empty</code>: empties given jug;</li>
<li><code>Fill</code>: fills given jug;</li>
<li><code>Transfer</code>: transfers water from one jug to another (until source jug is empty or target jug is full);</li>
</ul>
<p>These three last methods (<code>Empty</code>, <code>Fill</code> and <code>Transfer</code>) map directly to <code>Action</code> cases:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> applyAction (state: State) action =</span><br><span class="line">    <span class="keyword">match</span> action <span class="keyword">with</span></span><br><span class="line">    | Empty j -&gt; state.Empty j</span><br><span class="line">    | Fill j -&gt; state.Fill j</span><br><span class="line">    | Transfer (j, k) <span class="keyword">when</span> j &lt;&gt; k -&gt; state.Transfer j k</span><br><span class="line">    | _ -&gt; failwithf <span class="string">&quot;Invalid move: %A&quot;</span> action</span><br></pre></td></tr></table></figure>

<p>Having all this we can attempt to save New York, and in principle, it is the same operation as solving Bloxorz:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> saveNewYork target state =</span><br><span class="line">    <span class="keyword">let</span> idof s = sprintf <span class="string">&quot;%d/%d&quot;</span> s.A s.B</span><br><span class="line">    <span class="keyword">let</span> fanout s =</span><br><span class="line">        [Empty A; Empty B; Fill A; Fill B; Transfer (A, B); Transfer (B, A)]</span><br><span class="line">        |&gt; Seq.map (<span class="keyword">fun</span> action -&gt; (applyAction s action, action))</span><br><span class="line">    <span class="keyword">let</span> isDone s = s.A = target || s.B = target</span><br><span class="line"></span><br><span class="line">    trace bfs idof fanout state</span><br><span class="line">    |&gt; Seq.tryFind (<span class="keyword">fun</span> (state, _) -&gt; isDone state)</span><br><span class="line">    |&gt; Option.map (<span class="keyword">fun</span> (_, actions) -&gt; List.rev actions)</span><br></pre></td></tr></table></figure>

<p>We can identify visited states with <code>idof</code> to avoid running in circles, we can transition to new states with <code>fanout</code> by executing all the possible actions (<code>[Empty A; Empty B; Fill A; Fill B; Transfer (A, B); Transfer (B, A)]</code>), and we can check if we reached our goal (<code>isDone</code>). The last step is actually to scan solution space (<code>trace bfs idof fanout state</code>), terminating search when appropriate (<code>Seq.tryFind</code>) and reversing action history (as it is upside-down).</p>
<p>Let’s try:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newYork = State.Create(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">newYork |&gt; saveNewYork <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>which returns:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some [Fill B; Transfer (B,A); Empty A; Transfer (B,A); Fill B; Transfer (B,A)]</span><br></pre></td></tr></table></figure>

<p>Hmm, let’s replay all actions to see if it really worked. To do that I will actually use some dreaded imperative code:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newYork = State.Create(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> solution = newYork |&gt; saveNewYork <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mutable</span> curr = newYork</span><br><span class="line"><span class="keyword">for</span> action <span class="keyword">in</span> solution |&gt; Option.get <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">let</span> next = applyAction curr action</span><br><span class="line">    printfn <span class="string">&quot;%d/%d -&gt; %A -&gt; %d/%d&quot;</span> curr.A curr.B action next.A next.B</span><br><span class="line">    curr &lt;- next</span><br></pre></td></tr></table></figure>

<p>which generates readable description what has happened:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0/0 -&gt; Fill B -&gt; 0/5</span><br><span class="line">0/5 -&gt; Transfer (B,A) -&gt; 3/2</span><br><span class="line">3/2 -&gt; Empty A -&gt; 0/2</span><br><span class="line">0/2 -&gt; Transfer (B,A) -&gt; 2/0</span><br><span class="line">2/0 -&gt; Fill B -&gt; 2/5</span><br><span class="line">2/5 -&gt; Transfer (B,A) -&gt; 3/4</span><br></pre></td></tr></table></figure>

<p>and, yes, in fact we end up with 4 gallons in jug B. <strong>New York is saved!</strong></p>
<p>Please note, functional purists might say I should not use imperative loop with mutable variable, and use <code>Seq.scan |&gt; Seq.iter</code> instead. To be honest, I did that at first, but this imperative loop is actually much more readable even if not pure enough.</p>
<p>Let’s try something bigger:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">State.Create(<span class="number">113</span>, <span class="number">97</span>) |&gt; saveNewYork <span class="number">66</span></span><br></pre></td></tr></table></figure>

<p>returns:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Some [</span><br><span class="line">    Fill B; Transfer (B,A); Fill B; Transfer (B,A); Empty A; Transfer (B,A);</span><br><span class="line">    Fill B; Transfer (B,A); Empty A; Transfer (B,A); Fill B; Transfer (B,A);</span><br><span class="line">    Empty A; Transfer (B,A); Fill B; Transfer (B,A); Empty A; Transfer (B,A);</span><br><span class="line">    Fill B; Transfer (B,A); Empty A; Transfer (B,A); Fill B; Transfer (B,A);</span><br><span class="line">    Empty A; Transfer (B,A); Fill B; Transfer (B,A); Fill B; Transfer (B,A);</span><br><span class="line">    Empty A; Transfer (B,A); Fill B; Transfer (B,A)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>Let’s see it it crashes, or hangs up when there is no solution:</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">State.Create(<span class="number">12</span>, <span class="number">6</span>) |&gt; saveNewYork <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>Nope, it works just fine and returns <code>None</code>.</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I really like the idea that three seemingly different problems (scanning folders, pushing Bloxorz through the hole and saving New York) are actually the same problem, and all of them can be solved with the same function and a little bit of “adaptation”.<br>I also really liked the idea that it is possible to present 4 (out of 5) SOLID principles (plus CRP) in 5 lines of code and the fact that they come quite naturally in FP. Oh irony! OO principles are intrinsic to FP.<br>Other than that? Well… I don’t think my day-to-day JSON-over-HTTP activities require a lot of “Saving New York”, but when they do, I’m ready :-)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://red-green-rewrite.github.io/2018/03/10/Saving-New-York-with-F-Bloxorz-and-John-McClane/" data-id="ckthjm5yt001wz4jb7vrua1j2" class="article-share-link">Share</a>
      
        <a href="http://red-green-rewrite.github.io/2018/03/10/Saving-New-York-with-F-Bloxorz-and-John-McClane/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fable/" rel="tag">fable</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/fsharp/" rel="tag">fsharp</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/">__(&#39;next&#39;) &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/" rel="tag">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/csharp/" rel="tag">csharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/design/" rel="tag">design</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fable/" rel="tag">fable</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fsharp/" rel="tag">fsharp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/functional/" rel="tag">functional</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kata/" rel="tag">kata</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin/" rel="tag">kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/kotlin-js/" rel="tag">kotlin.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maze/" rel="tag">maze</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala/" rel="tag">scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/scala-js/" rel="tag">scala.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/state-machine/" rel="tag">state-machine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tree/" rel="tag">tree</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/algorithm/" style="font-size: 20px;">algorithm</a> <a href="/tags/csharp/" style="font-size: 14px;">csharp</a> <a href="/tags/design/" style="font-size: 12px;">design</a> <a href="/tags/fable/" style="font-size: 14px;">fable</a> <a href="/tags/fsharp/" style="font-size: 18px;">fsharp</a> <a href="/tags/functional/" style="font-size: 12px;">functional</a> <a href="/tags/kata/" style="font-size: 10px;">kata</a> <a href="/tags/kotlin/" style="font-size: 14px;">kotlin</a> <a href="/tags/kotlin-js/" style="font-size: 12px;">kotlin.js</a> <a href="/tags/maze/" style="font-size: 16px;">maze</a> <a href="/tags/scala/" style="font-size: 10px;">scala</a> <a href="/tags/scala-js/" style="font-size: 10px;">scala.js</a> <a href="/tags/state-machine/" style="font-size: 10px;">state-machine</a> <a href="/tags/tree/" style="font-size: 10px;">tree</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/10/Saving-New-York-with-F-Bloxorz-and-John-McClane/">Saving New York with F#, Bloxorz and John McClane</a>
          </li>
        
          <li>
            <a href="/2017/03/20/Further-than-SAM/">Further than SAM</a>
          </li>
        
          <li>
            <a href="/2017/03/12/You-are-better-off-with-SAM/">You are better off with SAM</a>
          </li>
        
          <li>
            <a href="/2016/10/30/Kruskal-DFS-hybrid-with-reduced-branching-factor/">Kruskal/DFS hybrid with reduced branching factor</a>
          </li>
        
          <li>
            <a href="/2016/10/06/Kruskal-Kotlin-and-Hex-Tiles/">Kruskal, Kotlin, and Hex Tiles</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Milosz Krajewski<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    
<script>
  var disqus_shortname = 'red-green-rewrite';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


  </div>
</body>
</html>